Signals:

1) Thread gets signal from other process (such as kill), add it to pending signals list
2) When starting a thread from sleep or returning from kernel mode, go thru pending signals and handle them 1 by 1
3) If signal is a user handler signal, call it then return control to operating system.

Asynchronous Signals (such as from kill)
1) Wake up process if it's sleeping, and add pending signal to its list
2) Process wakes up, and before entering back into user mode checks its pending signals
3) It has one, and it's a user signal, so it sets up its current trapframe to point into
the new handler, and sets the return address of the trapframe to point back to the original
trapframe program counter.

1) Inject assembly instructions at specific address, make it readable and executable, NOT writable [DONE]
2) Get signal handling to run and return using sigreturn syscall [DONE]
3) Get signal handling masking (blocking) to work [DONE]
4) Implement child to parent signals when child dies, etc (SIGCHLD)
  * Get fork working for inheriting various signal fields (mask, pending signals, signal actions, etc.) [DONE]
  * Test fork and signal handling [DONE]
  * implement reaping child processes in terms of SIGCHLD signal (instead of way it's done now) [TODO]
5) Fix pending signals array to make it larger and work for multiple pending signals, see what openBSD does [DONE]
6) Test multiple pending signals in an easy way from the menu (queuesig and runsigs commands, maybe?)
7) Get interrupted signal handlers working (signals handled in the middle of handling other signals)
  * Find a way to test them (sleep in signal handler)
8) Send signal using interrupts if possible, instead of adding signal to pending signals list. Otherwise we won't be able to truly
interrupt a signal handler unless it blocks (returns control to OS) or gets pre-empted.
